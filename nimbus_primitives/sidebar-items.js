initSidebarItems({"constant":[["INHERENT_IDENTIFIER","The InherentIdentifier for nimbus’s author inherent"],["NIMBUS_ENGINE_ID","The ConsensusEngineId for nimbus consensus this same identifier will be used regardless of the filters installed"],["NIMBUS_KEY_ID","The KeyTypeId used in the Nimbus consensus framework regardles of wat filters are in place. If this gets well adopted, we could move this definition to sp_core to avoid conflicts."]],"mod":[["digests","A convenient interface over the digests used in nimbus."]],"struct":[["InherentDataProvider","A thing that an outer node could use to inject the inherent data. This should be used in simple uses of the author inherent (eg permissionless authoring) When using the full nimbus system, we are manually inserting the inherent."],["IntervalBeacon","PLANNED: A SlotBeacon that starts a new slot based on the timestamp. Behaviorally, this is similar to what aura, babe and company do. Implementation-wise it is different because it depends on the timestamp pallet for its notion of time."]],"trait":[["AccountLookup","A Trait to lookup runtime AccountIds from AuthorIds (probably NimbusIds) The trait is generic over the AccountId, becuase different runtimes use different notions of AccoutId. It is also generic over the AuthorId to support the usecase where the author inherent is used for beneficiary info and contains an AccountId directly."],["AuthorFilterAPI","The runtime api used to predict whether an author will be eligible in the given slot"],["CanAuthor","Trait to determine whether this author is eligible to author in this slot. This is the primary trait your nimbus filter needs to implement."],["EventHandler","The given account ID is the author of the current block."],["SlotBeacon","A mechanism for determining the current slot. For now we use u32 as the slot type everywhere. Let’s see how long we can get away with that."]],"type":[["NimbusId","A nimbus author identifier (A public key)."],["NimbusPair","A nimbus keypair"],["NimbusSignature","A nimbus signature."]]});